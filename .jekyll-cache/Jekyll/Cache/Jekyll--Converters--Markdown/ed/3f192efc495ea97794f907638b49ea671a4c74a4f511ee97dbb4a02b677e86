I"⁄ƒ<!--
<div class="container">
    <div class="row">
        <div class="col-12">      
                
                <div class="row">
                    <div class="col-sm-12">
                        <div class="card bg-light mb-3">
                          <div class="card-body">
                            <h4 class="card-title">Go Concurrency - A typical production use</h4>
                            <p class="card-text"><p>Go handles concurrency in a slightly different way than the other programming languages. The effective Go has a slogan around their new concept</p>

<p>‚ÄúDo not communicate by sharing memory; instead, share memory by communicating‚Äù.</p>

<p>These Go routines are unique and they are not operating system threads. It is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. More you can read at the official documentation site  <a href="https://golang.org/doc/effective_go.html#concurrency">here</a></p>

<p>Enough of the concepts, let us delve into the code and apply these concepts. First, we will implement some example code to understand the concepts, after that we will do an identical code that we typically use in production. A typical goroutine is written below.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">1
2
3
4
5</pre></td><td><pre style="margin: 0; line-height: 125%">sayHello := <span style="color: #000080; font-weight: bold">func</span>() {
    fmt.Println(<span style="color: #0000FF">&quot;Techiebar is awesome!&quot;</span>)
}
<span style="color: #000080; font-weight: bold">go</span> sayHello()
<span style="color: #008800; font-style: italic">// continue doing rest of your code</span>
</pre></td></tr></table></div>

<p>Now, when you execute the above snippet, you might not see the output string <code class="language-plaintext highlighter-rouge">Techiebar is awesome!</code> that is due to the fact that the main thread might get finished its job well before the goroutine. One of the ways to handle this issue is by using Go <code class="language-plaintext highlighter-rouge">sync</code> package, check the below snippet.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #000080; font-weight: bold">var</span> wg sync.WaitGroup

wg.Add(<span style="color: #0000FF">1</span>)                       
<span style="color: #000080; font-weight: bold">go</span> <span style="color: #000080; font-weight: bold">func</span>() {
    <span style="color: #000080; font-weight: bold">defer</span> wg.Done()             
    fmt.Println(<span style="color: #0000FF">&quot;7:00AM Techiebar is closed!&quot;</span>)
}()

wg.Add(<span style="color: #0000FF">1</span>)                       
<span style="color: #000080; font-weight: bold">go</span> <span style="color: #000080; font-weight: bold">func</span>() {
    <span style="color: #000080; font-weight: bold">defer</span> wg.Done()             
    fmt.Println(<span style="color: #0000FF">&quot;5:00PM Techiebar is Opened!&quot;</span>)
}()

wg.Wait()                       
fmt.Println(<span style="color: #0000FF">&quot;All goroutines completed.&quot;</span>)
</pre></td></tr></table></div>

<p><code class="language-plaintext highlighter-rouge">WaitGroup</code> is a great way to wait for a set of concurrent operations to complete when you either don‚Äôt care about the result of the concurrent operation or you have other plans to collect the results.</p>

<p>There is another interesting method in the sync package is <code class="language-plaintext highlighter-rouge">once.Do(&lt;calling method&gt;)</code>, This will make sure that the calling method will be called once, even though it triggered by different routines. Try that by writing an example and check the behavior.</p>

<p>Now, the interesting concept is about co-ordinating the multiple Goroutines using channels.
Yes, Channel is a great way of sending and receiving the values. A typical channel example looks like below.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #000080; font-weight: bold">func</span> main() {
  <span style="color: #008800; font-style: italic">//We have some integers</span>
  elems := []<span style="color: #000080; font-weight: bold">int</span>{<span style="color: #0000FF">1</span>, <span style="color: #0000FF">2</span>, <span style="color: #0000FF">3</span>, <span style="color: #0000FF">4</span>, <span style="color: #0000FF">5</span>, <span style="color: #0000FF">0</span>} 

  <span style="color: #008800; font-style: italic">//Handle the sum of all integers</span>

  sum := <span style="color: #000080; font-weight: bold">func</span>(s []<span style="color: #000080; font-weight: bold">int</span>, c <span style="color: #000080; font-weight: bold">chan</span> <span style="color: #000080; font-weight: bold">int</span>) {
    sum := <span style="color: #0000FF">0</span>
    <span style="color: #000080; font-weight: bold">for</span> _, v := <span style="color: #000080; font-weight: bold">range</span> s {
      sum += v
    }
    c &lt;- sum <span style="color: #008800; font-style: italic">// sending sum to the channel</span>
  }
  <span style="color: #008800; font-style: italic">//We have created a channel of type int</span>
  <span style="color: #008800; font-style: italic">//Do note that, the channel can hold only one integer value</span>
  <span style="color: #008800; font-style: italic">// at a time</span>
  receiver := make(<span style="color: #000080; font-weight: bold">chan</span> <span style="color: #000080; font-weight: bold">int</span>)
  <span style="color: #000080; font-weight: bold">go</span> sum(elems, receiver)
  total := &lt;-receiver <span style="color: #008800; font-style: italic">// receiver returns the result of the sum</span>

  fmt.Println(total)
}
</pre></td></tr></table></div>

<p>So far everything is fine, we have routines, waitGroups, channels. But, what does a typical production code looks like to use channels with multiple goroutines. Now, let us take an example scenario where we have some 1000 requests[In production we will face 1000‚Äôs requests] that need to be processed and each request is independent and can be processed with a separate goroutine. That means if we spawn 10 goroutines as a worker pool to process the 1000 requests. Let us see how the code looks like.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic">//FullName is first + last name</span>
<span style="color: #000080; font-weight: bold">type</span> FullName <span style="color: #000080; font-weight: bold">struct</span> {
	FirstName <span style="color: #000080; font-weight: bold">string</span>
	LastName  <span style="color: #000080; font-weight: bold">string</span>
}

<span style="color: #000080; font-weight: bold">func</span> main() {
	fnChannel := make(<span style="color: #000080; font-weight: bold">chan</span> FullName)
	totalWorkers := <span style="color: #0000FF">10</span>
	<span style="color: #000080; font-weight: bold">var</span> wg sync.WaitGroup

	<span style="color: #008800; font-style: italic">// You have created 10 routines to handle your 1000 requests</span>
	<span style="color: #000080; font-weight: bold">for</span> i := <span style="color: #0000FF">0</span>; i &lt; totalWorkers; i++ {
		wg.Add(<span style="color: #0000FF">1</span>)
		<span style="color: #000080; font-weight: bold">go</span> <span style="color: #000080; font-weight: bold">func</span>() {
			<span style="color: #000080; font-weight: bold">defer</span> wg.Done()
			<span style="color: #000080; font-weight: bold">for</span> fn := <span style="color: #000080; font-weight: bold">range</span> fnChannel {
				printFullName(fn)
			}
		}()
	}

	<span style="color: #008800; font-style: italic">// You have 1000 requests, needs to be processed</span>
	<span style="color: #000080; font-weight: bold">for</span> j := <span style="color: #0000FF">0</span>; j &lt;= <span style="color: #0000FF">1000</span>; j++ {
		<span style="color: #008800; font-style: italic">// You are pushing one by one to the channel</span>
		fnChannel &lt;- FullName{
			FirstName: fmt.Sprintf(<span style="color: #0000FF">&quot;F%d&quot;</span>, j),
			LastName:  fmt.Sprintf(<span style="color: #0000FF">&quot;L%d&quot;</span>, j),
		}
	}
	close(fnChannel)
	wg.Wait()
	fmt.Println(<span style="color: #0000FF">&quot;Everything completed&quot;</span>)

}

<span style="color: #000080; font-weight: bold">func</span> printFullName(fn FullName) {
	fmt.Printf(<span style="color: #0000FF">&quot;%s %s\n&quot;</span>, fn.FirstName, fn.LastName)
}
</pre></td></tr></table></div>

<p>In the above example code, at line number 8 we have created a channel that accepts the <code class="language-plaintext highlighter-rouge">FullName</code> data structure and we have created 10 workers to take up our task of processing the full name. Finally, at line number 26 we started pushing the data to the channel. Now all the 10 goroutines start processing the given data and accept another set of data until the channel is closed.</p>

<p>For more information, it is always recommended to go through the Effective  <a href="https://golang.org/doc/effective_go.html#concurrency">Go concurrency</a>  documentation.</p>

<p>Share your constructive comments or suggestions to improve the content.</p>
<p>&lt;/p&gt;
                            <a href="/2020/11/19/go-concurrency.html" class="card-link">Read More‚Ä¶</a>
                          &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            &lt;div class="row"&gt;
                &lt;div class="col-sm-12"&gt;
                    &lt;div class="card bg-light mb-3"&gt;
                      &lt;div class="card-body"&gt;
                        &lt;h4 class="card-title"&gt;Day to Day Kubernetes Commandline Reference&lt;/h4&gt;
                        &lt;p class="card-text"&gt;&lt;p&gt;There are multiple resources for the Kubernetes &lt;code class="language-plaintext highlighter-rouge"&gt;kubectl&lt;/code&gt; command line reference. It is very good practice to learn the usage of all those commands. But, here I would like to share the most day to day commands that we use on the terminal to take care of our daily development and debugging activities with respect to Kubernetes.&lt;/p&gt;
</code></pre></div></div>

<p>To Get the Context</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># To get the current context</span>
$ kubectl config current-context

<span style="color: #008800; font-style: italic"># To Display list of contexts</span>
$ kubectl config get-contexts

<span style="color: #008800; font-style: italic"># Now, create the namespace in the cluster</span>
$ kubectl create namespace &lt;your namespace name&gt;

<span style="color: #008800; font-style: italic"># Use the namespace for the subsequent kubectl operations</span>
$ kubectl config set-context --namespace=&lt;your namespace name&gt; --current
</pre></td></tr></table></div>

<p>Namespace Commands</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">1
2
3
4
5
6
7
8
9</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># Describe the namespace</span>
$ kubectl describe namespace &lt;your namespace name&gt;

<span style="color: #008800; font-style: italic"># Get the namespace details either in yaml or json</span>
$ kubectl get namespace blog-ns -o json
$ kubectl get namespace blog-ns -o yaml

<span style="color: #008800; font-style: italic"># To list all the resources under a namespace</span>
$ kubectl get all -n &lt;your namespace name&gt; 
</pre></td></tr></table></div>

<p>ConfigMap and Secretes Commands</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># Create a config map</span>
$ kubectl create configmap &lt;name of the config map&gt; --from-literal=username=user --from-literal=hostname=host

<span style="color: #008800; font-style: italic"># Create a secret</span>
<span style="color: #008800; font-style: italic"># Remember Secretes are namespace specific, they can not be accessed across the namespaces</span>
$ kubectl create secret generic &lt;secret name&gt; --from-literal=&lt;key&gt;=&lt;value&gt;

<span style="color: #008800; font-style: italic"># Whenever you store a secret, you should store them in a base64 format</span>
$ echo -n &lt;your password&gt; | base64

<span style="color: #008800; font-style: italic"># To decode the value</span>
$ echo -n <span style="color: #0000FF">&#39;base 64 value&#39;</span> | base64 -decode
</pre></td></tr></table></div>

<p>Deployment and Pod Commands</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># List all the pods in all namespaces</span>
$ kubectl get pods --all-namespaces 

<span style="color: #008800; font-style: italic"># Create a POD quickly</span>
$ kubectl run &lt;pod name&gt; --image=busybox --restart=Never -n &lt;your namespace&gt;

<span style="color: #008800; font-style: italic"># In some cases, you just need the pod yaml</span>
$ kubectl run &lt;pod name&gt; --image=nginx --dry-run=client --restart=Never -n &lt;your namespace&gt; -o yaml

<span style="color: #008800; font-style: italic"># Rolling Update of the deployment image</span>
$ kubectl set image deployment/&lt;deployment name&gt; &lt;containername&gt;=&lt;new image name&gt;

<span style="color: #008800; font-style: italic"># Restart the deployment</span>
$ kubectl rollout restart deployment/&lt;deployment name&gt;

<span style="color: #008800; font-style: italic"># To undo the rollout</span>
$ kubectl rollout undo deployment/&lt;deployment name&gt;

<span style="color: #008800; font-style: italic"># To know the rollout history of a deployment</span>
$ kubectl rollout history deployment &lt;deployment name&gt;

<span style="color: #008800; font-style: italic"># To view the logs</span>
$ kubectl logs &lt;podname&gt; --namespace=&lt;namespace name&gt;

<span style="color: #008800; font-style: italic"># To open the interactive shell to the pod</span>
$ kubectl exec -it &lt;pod name&gt; --namespace=&lt;namespace name&gt; -- /bin/sh

<span style="color: #008800; font-style: italic"># To check the evens on the pod</span>
$ kubectl describe pod &lt;pod name&gt; | grep -C 10 Events:

<span style="color: #008800; font-style: italic"># Extract a pod definition yaml file to local file</span>
$ kubectl get pod &lt;podname&gt; -o yaml &gt; &lt;local pod filename&gt;.yaml
</pre></td></tr></table></div>

<p>Searching or Listing Commands</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># List the resources in a sorted order by any of the metadata</span>
$ kubectl get services --sort-by=.metadata.name

<span style="color: #008800; font-style: italic"># Get the particular fields displayed from the resources</span>
<span style="color: #008800; font-style: italic"># If it is a list then, use names[*].abc</span>
$ kkubectl get services -A -o custom-columns=<span style="color: #0000FF">&#39;NAME:metadata.name&#39;</span>

<span style="color: #008800; font-style: italic"># List the resources with specific label</span>
$ kubectl get pod -l &lt;label name&gt;=&lt;label value&gt;
$ kubectl get pods --selector &lt;label name&gt;=&lt;label value&gt;

<span style="color: #008800; font-style: italic"># To list all of the resources matching with the label</span>
$ kubectl get all --selector &lt;lable name&gt;=&lt;label value&gt;
</pre></td></tr></table></div>

<p>All the above command reference is the typical actions we do as a Cloud Developer/Engineer in our day to day activities. But for more references the ocean like documentation available at  <a href="https://kubernetes.io/docs/home/">here</a></p>
<p>&lt;/p&gt;
                            <a href="/2020/11/18/day-to-day-kubernetes.html" class="card-link">Read More‚Ä¶</a>
                          &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            &lt;div class="row"&gt;
                &lt;div class="col-sm-12"&gt;
                    &lt;div class="card bg-light mb-3"&gt;
                      &lt;div class="card-body"&gt;
                        &lt;h4 class="card-title"&gt;Use Makefile for your daily development tasks&lt;/h4&gt;
                        &lt;p class="card-text"&gt;&lt;p&gt;A typical routine of a developer is code, build, unit test, and deploy. Most of the time, developers do all these tasks in their local first and once everything is fine then they move to the next state. This will be a very much repeated process when we work on a microservices architecture.&lt;/p&gt;
</code></pre></div></div>

<p>From my experience, If I can list out a typical list of tasks for a go language-based microservice. Those are</p>

<ol>
  <li>Clean</li>
  <li>Format</li>
  <li>Lint</li>
  <li>Dependencies</li>
  <li>Run Unit tests</li>
  <li>Build</li>
  <li>Push to Dev Quay</li>
  <li>Coverage Report</li>
</ol>

<p>All these steps can be placed in a simple Makefile and then onwards, the same can be used by anyone to quickly take the charge and move on. This kind is one of the best practices when it comes to day-to-day development activity [I am not denying that there are multiple ways of achieving the same]. Here is the typical Makefile from my experience.</p>

<p>The below sample make file is specific to Go language-based environment but I believe the idea can be used to leverage with any other project.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># Enable dependencies and configure the private repo</span>
GO = GO111MODULE=on GOPRIVATE=&lt;your private repo&gt;.cisco.com
EXEFILE = ./bin/&lt;exe file name&gt;
MAIN_GO = &lt;your service main.go file location&gt;

<span style="color: #008800; font-style: italic"># help messages</span>
help:
    @echo <span style="color: #0000FF">&#39;Available commands for the &lt;your micro service name&gt;&#39;</span>
    @echo <span style="color: #0000FF">&#39;Usage&#39;</span>
    @echo <span style="color: #0000FF">&#39;  all - Run all the available commands&#39;</span>
    @echo <span style="color: #0000FF">&#39;  clean - Run the clean up&#39;</span>
    @echo <span style="color: #0000FF">&#39;  setup -  Run the initial setup instructions&#39;</span>
    @echo <span style="color: #0000FF">&#39;  format - Run code format&#39;</span>
    @echo <span style="color: #0000FF">&#39;  staticanalysis - Run the static code analysis&#39;</span>
    @echo <span style="color: #0000FF">&#39;  dependencies - Run the dependencies&#39;</span>
    @echo <span style="color: #0000FF">&#39;  unittest - Run unit tests&#39;</span>
    @echo <span style="color: #0000FF">&#39;  localbuild - Build the executable&#39;</span>

<span style="color: #008800; font-style: italic"># Run all the available commands in the below order</span>
all: <span style="color: #0000FF">clean setup dependencies format staticanalysis unittest localbuild</span>

clean:
    @echo <span style="color: #0000FF">&quot;Cleaning the previous executable and coverage reports&quot;</span>
    rm -f coveragereport.out report.json
    rm -f <span style="color: #000080; font-weight: bold">${</span>EXEFILE <span style="color: #000080; font-weight: bold">}</span>

setup:
    @echo <span style="color: #0000FF">&quot;Add any steps that are needed&quot;</span>
    &lt;some installation tasks&gt;
format:
    @echo <span style="color: #0000FF">&quot;Code Formatting&quot;</span>
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> fmt ./...
staticanalysis:
    @echo <span style="color: #0000FF">&quot;&quot;</span>
    golangci-lint run -c .golangci.yaml
dependencies:
    @echo <span style="color: #0000FF">&#39; Load Dependencies&#39;</span>
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> mod tidy
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> mod download
unittest:
    @echo <span style="color: #0000FF">&quot;Executing Unit tests&quot;</span>
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> test -v covermode=atomic -count=1 ./... -coverprofile coveragereport.out
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> test -race test -covermode=atomic -count=1 ./... -json &gt; report.json
localbuild:
    @echo <span style="color: #0000FF">&quot;Loca build&quot;</span>
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> build -o <span style="color: #000080; font-weight: bold">${</span>EXEFILE<span style="color: #000080; font-weight: bold">}</span> <span style="color: #000080; font-weight: bold">${</span>MAIN_GO<span style="color: #000080; font-weight: bold">}</span>
    docker build -t &lt;your tag name&gt; .
    docker tag &lt;your tag name&gt; &lt;your quay repo location&gt;:latest
    docker push &lt;your quay repo location&gt;:latest
</pre></td></tr></table></div>

<p>&lt;/p&gt;
                            <a href="/2020/11/17/use-makefile-for-your-daily-development-tasks.html" class="card-link">Read More‚Ä¶</a>
                          &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;/div&gt;
&lt;/div&gt;
</code></pre></div></div>
<p>&lt;/div&gt;
‚Äì&gt;</p>

<div class="row row-cols-1 row-cols-md-3">
  <div class="col mb-10">
    <div class="card h-100">
      <!--Card image-->
      <div class="view overlay">
        <img class="card-img-top" src="https://mdbootstrap.com/img/Photos/Others/images/16.jpg" alt="Card image cap" />
        <a href="#!">
          <div class="mask rgba-white-slight"></div>
        </a>
      </div>
      <!--Card content-->
      <div class="card-body">
        <!--Title-->
        <h4 class="card-title">Go Concurrency - A typical production use</h4>
        <p class="card-title">Published on Nov 19, 2020</p>
        <!--Text-->
        <p class="card-text"><p>Go handles concurrency in a slightly different way than the other programming languages. The effective Go has a slogan around their new concept</p>

<p>‚ÄúDo not communicate by sharing memory; instead, share memory by communicating‚Äù.</p>

<p>These Go routines are unique and they are not operating system threads. It is a function executing concurrently with other goroutines in the same address space. It is lightweight, costing little more than the allocation of stack space. More you can read at the official documentation site  <a href="https://golang.org/doc/effective_go.html#concurrency">here</a></p>

<p>Enough of the concepts, let us delve into the code and apply these concepts. First, we will implement some example code to understand the concepts, after that we will do an identical code that we typically use in production. A typical goroutine is written below.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">1
2
3
4
5</pre></td><td><pre style="margin: 0; line-height: 125%">sayHello := <span style="color: #000080; font-weight: bold">func</span>() {
    fmt.Println(<span style="color: #0000FF">&quot;Techiebar is awesome!&quot;</span>)
}
<span style="color: #000080; font-weight: bold">go</span> sayHello()
<span style="color: #008800; font-style: italic">// continue doing rest of your code</span>
</pre></td></tr></table></div>

<p>Now, when you execute the above snippet, you might not see the output string <code class="language-plaintext highlighter-rouge">Techiebar is awesome!</code> that is due to the fact that the main thread might get finished its job well before the goroutine. One of the ways to handle this issue is by using Go <code class="language-plaintext highlighter-rouge">sync</code> package, check the below snippet.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #000080; font-weight: bold">var</span> wg sync.WaitGroup

wg.Add(<span style="color: #0000FF">1</span>)                       
<span style="color: #000080; font-weight: bold">go</span> <span style="color: #000080; font-weight: bold">func</span>() {
    <span style="color: #000080; font-weight: bold">defer</span> wg.Done()             
    fmt.Println(<span style="color: #0000FF">&quot;7:00AM Techiebar is closed!&quot;</span>)
}()

wg.Add(<span style="color: #0000FF">1</span>)                       
<span style="color: #000080; font-weight: bold">go</span> <span style="color: #000080; font-weight: bold">func</span>() {
    <span style="color: #000080; font-weight: bold">defer</span> wg.Done()             
    fmt.Println(<span style="color: #0000FF">&quot;5:00PM Techiebar is Opened!&quot;</span>)
}()

wg.Wait()                       
fmt.Println(<span style="color: #0000FF">&quot;All goroutines completed.&quot;</span>)
</pre></td></tr></table></div>

<p><code class="language-plaintext highlighter-rouge">WaitGroup</code> is a great way to wait for a set of concurrent operations to complete when you either don‚Äôt care about the result of the concurrent operation or you have other plans to collect the results.</p>

<p>There is another interesting method in the sync package is <code class="language-plaintext highlighter-rouge">once.Do(&lt;calling method&gt;)</code>, This will make sure that the calling method will be called once, even though it triggered by different routines. Try that by writing an example and check the behavior.</p>

<p>Now, the interesting concept is about co-ordinating the multiple Goroutines using channels.
Yes, Channel is a great way of sending and receiving the values. A typical channel example looks like below.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #000080; font-weight: bold">func</span> main() {
  <span style="color: #008800; font-style: italic">//We have some integers</span>
  elems := []<span style="color: #000080; font-weight: bold">int</span>{<span style="color: #0000FF">1</span>, <span style="color: #0000FF">2</span>, <span style="color: #0000FF">3</span>, <span style="color: #0000FF">4</span>, <span style="color: #0000FF">5</span>, <span style="color: #0000FF">0</span>} 

  <span style="color: #008800; font-style: italic">//Handle the sum of all integers</span>

  sum := <span style="color: #000080; font-weight: bold">func</span>(s []<span style="color: #000080; font-weight: bold">int</span>, c <span style="color: #000080; font-weight: bold">chan</span> <span style="color: #000080; font-weight: bold">int</span>) {
    sum := <span style="color: #0000FF">0</span>
    <span style="color: #000080; font-weight: bold">for</span> _, v := <span style="color: #000080; font-weight: bold">range</span> s {
      sum += v
    }
    c &lt;- sum <span style="color: #008800; font-style: italic">// sending sum to the channel</span>
  }
  <span style="color: #008800; font-style: italic">//We have created a channel of type int</span>
  <span style="color: #008800; font-style: italic">//Do note that, the channel can hold only one integer value</span>
  <span style="color: #008800; font-style: italic">// at a time</span>
  receiver := make(<span style="color: #000080; font-weight: bold">chan</span> <span style="color: #000080; font-weight: bold">int</span>)
  <span style="color: #000080; font-weight: bold">go</span> sum(elems, receiver)
  total := &lt;-receiver <span style="color: #008800; font-style: italic">// receiver returns the result of the sum</span>

  fmt.Println(total)
}
</pre></td></tr></table></div>

<p>So far everything is fine, we have routines, waitGroups, channels. But, what does a typical production code looks like to use channels with multiple goroutines. Now, let us take an example scenario where we have some 1000 requests[In production we will face 1000‚Äôs requests] that need to be processed and each request is independent and can be processed with a separate goroutine. That means if we spawn 10 goroutines as a worker pool to process the 1000 requests. Let us see how the code looks like.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic">//FullName is first + last name</span>
<span style="color: #000080; font-weight: bold">type</span> FullName <span style="color: #000080; font-weight: bold">struct</span> {
	FirstName <span style="color: #000080; font-weight: bold">string</span>
	LastName  <span style="color: #000080; font-weight: bold">string</span>
}

<span style="color: #000080; font-weight: bold">func</span> main() {
	fnChannel := make(<span style="color: #000080; font-weight: bold">chan</span> FullName)
	totalWorkers := <span style="color: #0000FF">10</span>
	<span style="color: #000080; font-weight: bold">var</span> wg sync.WaitGroup

	<span style="color: #008800; font-style: italic">// You have created 10 routines to handle your 1000 requests</span>
	<span style="color: #000080; font-weight: bold">for</span> i := <span style="color: #0000FF">0</span>; i &lt; totalWorkers; i++ {
		wg.Add(<span style="color: #0000FF">1</span>)
		<span style="color: #000080; font-weight: bold">go</span> <span style="color: #000080; font-weight: bold">func</span>() {
			<span style="color: #000080; font-weight: bold">defer</span> wg.Done()
			<span style="color: #000080; font-weight: bold">for</span> fn := <span style="color: #000080; font-weight: bold">range</span> fnChannel {
				printFullName(fn)
			}
		}()
	}

	<span style="color: #008800; font-style: italic">// You have 1000 requests, needs to be processed</span>
	<span style="color: #000080; font-weight: bold">for</span> j := <span style="color: #0000FF">0</span>; j &lt;= <span style="color: #0000FF">1000</span>; j++ {
		<span style="color: #008800; font-style: italic">// You are pushing one by one to the channel</span>
		fnChannel &lt;- FullName{
			FirstName: fmt.Sprintf(<span style="color: #0000FF">&quot;F%d&quot;</span>, j),
			LastName:  fmt.Sprintf(<span style="color: #0000FF">&quot;L%d&quot;</span>, j),
		}
	}
	close(fnChannel)
	wg.Wait()
	fmt.Println(<span style="color: #0000FF">&quot;Everything completed&quot;</span>)

}

<span style="color: #000080; font-weight: bold">func</span> printFullName(fn FullName) {
	fmt.Printf(<span style="color: #0000FF">&quot;%s %s\n&quot;</span>, fn.FirstName, fn.LastName)
}
</pre></td></tr></table></div>

<p>In the above example code, at line number 8 we have created a channel that accepts the <code class="language-plaintext highlighter-rouge">FullName</code> data structure and we have created 10 workers to take up our task of processing the full name. Finally, at line number 26 we started pushing the data to the channel. Now all the 10 goroutines start processing the given data and accept another set of data until the channel is closed.</p>

<p>For more information, it is always recommended to go through the Effective  <a href="https://golang.org/doc/effective_go.html#concurrency">Go concurrency</a>  documentation.</p>

<p>Share your constructive comments or suggestions to improve the content.</p>
</p>
        <!-- Provides extra visual weight and identifies the primary action in a set of buttons -->
        <button type="button" class="btn btn-md"><a href="/2020/11/19/go-concurrency.html" class="card-link">Read More...</a></button>
      </div>
    </div>
    <!-- Card -->
  </div>
</div>

<div class="row row-cols-1 row-cols-md-3">
  <div class="col mb-10">
    <div class="card h-100">
      <!--Card image-->
      <div class="view overlay">
        <img class="card-img-top" src="https://mdbootstrap.com/img/Photos/Others/images/16.jpg" alt="Card image cap" />
        <a href="#!">
          <div class="mask rgba-white-slight"></div>
        </a>
      </div>
      <!--Card content-->
      <div class="card-body">
        <!--Title-->
        <h4 class="card-title">Day to Day Kubernetes Commandline Reference</h4>
        <p class="card-title">Published on Nov 18, 2020</p>
        <!--Text-->
        <p class="card-text"><p>There are multiple resources for the Kubernetes <code class="language-plaintext highlighter-rouge">kubectl</code> command line reference. It is very good practice to learn the usage of all those commands. But, here I would like to share the most day to day commands that we use on the terminal to take care of our daily development and debugging activities with respect to Kubernetes.</p>

<p>To Get the Context</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># To get the current context</span>
$ kubectl config current-context

<span style="color: #008800; font-style: italic"># To Display list of contexts</span>
$ kubectl config get-contexts

<span style="color: #008800; font-style: italic"># Now, create the namespace in the cluster</span>
$ kubectl create namespace &lt;your namespace name&gt;

<span style="color: #008800; font-style: italic"># Use the namespace for the subsequent kubectl operations</span>
$ kubectl config set-context --namespace=&lt;your namespace name&gt; --current
</pre></td></tr></table></div>

<p>Namespace Commands</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">1
2
3
4
5
6
7
8
9</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># Describe the namespace</span>
$ kubectl describe namespace &lt;your namespace name&gt;

<span style="color: #008800; font-style: italic"># Get the namespace details either in yaml or json</span>
$ kubectl get namespace blog-ns -o json
$ kubectl get namespace blog-ns -o yaml

<span style="color: #008800; font-style: italic"># To list all the resources under a namespace</span>
$ kubectl get all -n &lt;your namespace name&gt; 
</pre></td></tr></table></div>

<p>ConfigMap and Secretes Commands</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># Create a config map</span>
$ kubectl create configmap &lt;name of the config map&gt; --from-literal=username=user --from-literal=hostname=host

<span style="color: #008800; font-style: italic"># Create a secret</span>
<span style="color: #008800; font-style: italic"># Remember Secretes are namespace specific, they can not be accessed across the namespaces</span>
$ kubectl create secret generic &lt;secret name&gt; --from-literal=&lt;key&gt;=&lt;value&gt;

<span style="color: #008800; font-style: italic"># Whenever you store a secret, you should store them in a base64 format</span>
$ echo -n &lt;your password&gt; | base64

<span style="color: #008800; font-style: italic"># To decode the value</span>
$ echo -n <span style="color: #0000FF">&#39;base 64 value&#39;</span> | base64 -decode
</pre></td></tr></table></div>

<p>Deployment and Pod Commands</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># List all the pods in all namespaces</span>
$ kubectl get pods --all-namespaces 

<span style="color: #008800; font-style: italic"># Create a POD quickly</span>
$ kubectl run &lt;pod name&gt; --image=busybox --restart=Never -n &lt;your namespace&gt;

<span style="color: #008800; font-style: italic"># In some cases, you just need the pod yaml</span>
$ kubectl run &lt;pod name&gt; --image=nginx --dry-run=client --restart=Never -n &lt;your namespace&gt; -o yaml

<span style="color: #008800; font-style: italic"># Rolling Update of the deployment image</span>
$ kubectl set image deployment/&lt;deployment name&gt; &lt;containername&gt;=&lt;new image name&gt;

<span style="color: #008800; font-style: italic"># Restart the deployment</span>
$ kubectl rollout restart deployment/&lt;deployment name&gt;

<span style="color: #008800; font-style: italic"># To undo the rollout</span>
$ kubectl rollout undo deployment/&lt;deployment name&gt;

<span style="color: #008800; font-style: italic"># To know the rollout history of a deployment</span>
$ kubectl rollout history deployment &lt;deployment name&gt;

<span style="color: #008800; font-style: italic"># To view the logs</span>
$ kubectl logs &lt;podname&gt; --namespace=&lt;namespace name&gt;

<span style="color: #008800; font-style: italic"># To open the interactive shell to the pod</span>
$ kubectl exec -it &lt;pod name&gt; --namespace=&lt;namespace name&gt; -- /bin/sh

<span style="color: #008800; font-style: italic"># To check the evens on the pod</span>
$ kubectl describe pod &lt;pod name&gt; | grep -C 10 Events:

<span style="color: #008800; font-style: italic"># Extract a pod definition yaml file to local file</span>
$ kubectl get pod &lt;podname&gt; -o yaml &gt; &lt;local pod filename&gt;.yaml
</pre></td></tr></table></div>

<p>Searching or Listing Commands</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># List the resources in a sorted order by any of the metadata</span>
$ kubectl get services --sort-by=.metadata.name

<span style="color: #008800; font-style: italic"># Get the particular fields displayed from the resources</span>
<span style="color: #008800; font-style: italic"># If it is a list then, use names[*].abc</span>
$ kkubectl get services -A -o custom-columns=<span style="color: #0000FF">&#39;NAME:metadata.name&#39;</span>

<span style="color: #008800; font-style: italic"># List the resources with specific label</span>
$ kubectl get pod -l &lt;label name&gt;=&lt;label value&gt;
$ kubectl get pods --selector &lt;label name&gt;=&lt;label value&gt;

<span style="color: #008800; font-style: italic"># To list all of the resources matching with the label</span>
$ kubectl get all --selector &lt;lable name&gt;=&lt;label value&gt;
</pre></td></tr></table></div>

<p>All the above command reference is the typical actions we do as a Cloud Developer/Engineer in our day to day activities. But for more references the ocean like documentation available at  <a href="https://kubernetes.io/docs/home/">here</a></p>
</p>
        <!-- Provides extra visual weight and identifies the primary action in a set of buttons -->
        <button type="button" class="btn btn-md"><a href="/2020/11/18/day-to-day-kubernetes.html" class="card-link">Read More...</a></button>
      </div>
    </div>
    <!-- Card -->
  </div>
</div>

<div class="row row-cols-1 row-cols-md-3">
  <div class="col mb-10">
    <div class="card h-100">
      <!--Card image-->
      <div class="view overlay">
        <img class="card-img-top" src="https://mdbootstrap.com/img/Photos/Others/images/16.jpg" alt="Card image cap" />
        <a href="#!">
          <div class="mask rgba-white-slight"></div>
        </a>
      </div>
      <!--Card content-->
      <div class="card-body">
        <!--Title-->
        <h4 class="card-title">Use Makefile for your daily development tasks</h4>
        <p class="card-title">Published on Nov 17, 2020</p>
        <!--Text-->
        <p class="card-text"><p>A typical routine of a developer is code, build, unit test, and deploy. Most of the time, developers do all these tasks in their local first and once everything is fine then they move to the next state. This will be a very much repeated process when we work on a microservices architecture.</p>

<p>From my experience, If I can list out a typical list of tasks for a go language-based microservice. Those are</p>

<ol>
  <li>Clean</li>
  <li>Format</li>
  <li>Lint</li>
  <li>Dependencies</li>
  <li>Run Unit tests</li>
  <li>Build</li>
  <li>Push to Dev Quay</li>
  <li>Coverage Report</li>
</ol>

<p>All these steps can be placed in a simple Makefile and then onwards, the same can be used by anyone to quickly take the charge and move on. This kind is one of the best practices when it comes to day-to-day development activity [I am not denying that there are multiple ways of achieving the same]. Here is the typical Makefile from my experience.</p>

<p>The below sample make file is specific to Go language-based environment but I believe the idea can be used to leverage with any other project.</p>

<!-- HTML generated using hilite.me -->
<div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49</pre></td><td><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-style: italic"># Enable dependencies and configure the private repo</span>
GO = GO111MODULE=on GOPRIVATE=&lt;your private repo&gt;.cisco.com
EXEFILE = ./bin/&lt;exe file name&gt;
MAIN_GO = &lt;your service main.go file location&gt;

<span style="color: #008800; font-style: italic"># help messages</span>
help:
    @echo <span style="color: #0000FF">&#39;Available commands for the &lt;your micro service name&gt;&#39;</span>
    @echo <span style="color: #0000FF">&#39;Usage&#39;</span>
    @echo <span style="color: #0000FF">&#39;  all - Run all the available commands&#39;</span>
    @echo <span style="color: #0000FF">&#39;  clean - Run the clean up&#39;</span>
    @echo <span style="color: #0000FF">&#39;  setup -  Run the initial setup instructions&#39;</span>
    @echo <span style="color: #0000FF">&#39;  format - Run code format&#39;</span>
    @echo <span style="color: #0000FF">&#39;  staticanalysis - Run the static code analysis&#39;</span>
    @echo <span style="color: #0000FF">&#39;  dependencies - Run the dependencies&#39;</span>
    @echo <span style="color: #0000FF">&#39;  unittest - Run unit tests&#39;</span>
    @echo <span style="color: #0000FF">&#39;  localbuild - Build the executable&#39;</span>

<span style="color: #008800; font-style: italic"># Run all the available commands in the below order</span>
all: <span style="color: #0000FF">clean setup dependencies format staticanalysis unittest localbuild</span>

clean:
    @echo <span style="color: #0000FF">&quot;Cleaning the previous executable and coverage reports&quot;</span>
    rm -f coveragereport.out report.json
    rm -f <span style="color: #000080; font-weight: bold">${</span>EXEFILE <span style="color: #000080; font-weight: bold">}</span>

setup:
    @echo <span style="color: #0000FF">&quot;Add any steps that are needed&quot;</span>
    &lt;some installation tasks&gt;
format:
    @echo <span style="color: #0000FF">&quot;Code Formatting&quot;</span>
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> fmt ./...
staticanalysis:
    @echo <span style="color: #0000FF">&quot;&quot;</span>
    golangci-lint run -c .golangci.yaml
dependencies:
    @echo <span style="color: #0000FF">&#39; Load Dependencies&#39;</span>
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> mod tidy
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> mod download
unittest:
    @echo <span style="color: #0000FF">&quot;Executing Unit tests&quot;</span>
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> test -v covermode=atomic -count=1 ./... -coverprofile coveragereport.out
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> test -race test -covermode=atomic -count=1 ./... -json &gt; report.json
localbuild:
    @echo <span style="color: #0000FF">&quot;Loca build&quot;</span>
    <span style="color: #000080; font-weight: bold">${</span>GO<span style="color: #000080; font-weight: bold">}</span> build -o <span style="color: #000080; font-weight: bold">${</span>EXEFILE<span style="color: #000080; font-weight: bold">}</span> <span style="color: #000080; font-weight: bold">${</span>MAIN_GO<span style="color: #000080; font-weight: bold">}</span>
    docker build -t &lt;your tag name&gt; .
    docker tag &lt;your tag name&gt; &lt;your quay repo location&gt;:latest
    docker push &lt;your quay repo location&gt;:latest
</pre></td></tr></table></div>

</p>
        <!-- Provides extra visual weight and identifies the primary action in a set of buttons -->
        <button type="button" class="btn btn-md"><a href="/2020/11/17/use-makefile-for-your-daily-development-tasks.html" class="card-link">Read More...</a></button>
      </div>
    </div>
    <!-- Card -->
  </div>
</div>
:ET